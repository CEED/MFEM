template <
   typename kernels_tuple,
   size_t num_solutions,
   size_t num_parameters,
   size_t num_fields,
   size_t num_kernels
   >
template <
   typename kernel_t
   >
void DifferentiableOperator<kernels_tuple,
     num_solutions,
     num_parameters,
     num_fields,
     num_kernels>::Action::create_action_callback(
        kernel_t kernel,
        mult_func_t &func)
{
   using entity_t = typename kernel_t::entity_t;

   auto kinput_to_field = create_descriptors_to_fields_map<entity_t>(op.fields,
                                                                     kernel.inputs, std::make_index_sequence<kernel.num_kinputs> {});

   auto koutput_to_field = create_descriptors_to_fields_map<entity_t>(op.fields,
                                                                      kernel.outputs, std::make_index_sequence<kernel.num_koutputs> {});

   constexpr int hardcoded_output_idx = 0;
   const int test_space_field_idx = koutput_to_field[hardcoded_output_idx];

   const Operator *R = get_restriction<entity_t>(op.fields[test_space_field_idx],
                                                 element_dof_ordering);

   auto output_fop = serac::get<0>(kernel.outputs);

   const int num_elements = GetNumEntities<Entity::Element>(op.mesh);
   const int num_entities = GetNumEntities<entity_t>(op.mesh);
   const int num_qp = op.integration_rule.GetNPoints();

   // All solutions T-vector sizes make up the width of the operator, since
   // they are explicitly provided in Mult() for example.

   op.width = GetTrueVSize(op.fields[test_space_field_idx]);
   op.residual_lsize = GetVSize(op.fields[test_space_field_idx]);

   if constexpr (std::is_same_v<decltype(output_fop), One>)
   {
      op.height = 1;
   }
   else
   {
      op.height = op.residual_lsize;
   }

   residual_l.SetSize(op.residual_lsize);

   // assume only a single element type for now
   std::vector<const DofToQuad*> dtq;
   for (const auto &field : op.fields)
   {
      dtq.emplace_back(GetDofToQuad<entity_t>(field, op.integration_rule,
                                              doftoquad_mode));
   }

   residual_e.SetSize(R->Height());

   const int residual_size_on_qp = GetSizeOnQP<entity_t>(
                                      serac::get<hardcoded_output_idx>(kernel.outputs),
                                      op.fields[test_space_field_idx]);

   residual_qp_mem.SetSize(residual_size_on_qp * num_qp * num_entities);

   // Allocate memory for fields on quadrature points
   auto input_qp_global_mem = create_input_qp_memory(num_qp, num_entities,
                                                     kernel.inputs,
                                                     std::make_index_sequence<kernel.num_kinputs> {});

   auto input_dtq_maps = create_dtq_maps<entity_t>(kernel.inputs, dtq,
                                                   kinput_to_field);
   auto output_dtq_maps = create_dtq_maps<entity_t>(kernel.outputs, dtq,
                                                    koutput_to_field);

   auto input_fops = create_bare_fops(kernel.inputs);
   auto output_fops = create_bare_fops(kernel.outputs);

   const int test_vdim = serac::get<hardcoded_output_idx>(input_fops).vdim;
   const int test_op_dim =
      serac::get<hardcoded_output_idx>(output_fops).size_on_qp /
      serac::get<hardcoded_output_idx>(output_fops).vdim;
   const int num_test_dof = R->Height() /
                            serac::get<hardcoded_output_idx>(output_fops).vdim /
                            num_entities;

   GeometricFactorMaps geometric_factors =
      GetGeometricFactorMaps<entity_t>(op.mesh, op.integration_rule);

   // kernel function output
   Vector f_qp(residual_size_on_qp);

   // TODO: replace by shared mem
   // Fields interpolated to the quadrature points in the order of
   // kernel function arguments
   // auto input_qp_global = wrap_input_memory(input_qp_global_mem, num_qp,
   //                                          num_entities, kernel.inputs,
   //                                          std::make_index_sequence<kernel.num_kinputs> {});

   auto input_size_on_qp = get_input_size_on_qp(kernel.inputs,
                                                std::make_index_sequence<kernel.num_kinputs> {});

   auto shmem_info = get_shmem_info<entity_t>(input_dtq_maps,
                                              output_dtq_maps,
                                              op.fields,
                                              num_entities,
                                              kernel.inputs,
                                              num_qp,
                                              input_size_on_qp);

   Vector shmem_cache(shmem_info.total_size);

   out << "Shared Memory Info\n"
       << "total size: " << shmem_info.total_size << "\n";
   out << "dtq sizes: ";
   for (auto &i : shmem_info.dtq_sizes)
   {
      out << i << " ";
   }
   out << "\n";
   out << "field sizes: ";
   for (auto &i : shmem_info.field_sizes)
   {
      out << i << " ";
   }
   out << "\n";
   out << "input sizes: ";
   for (auto &i : shmem_info.input_sizes)
   {
      out << i << " ";
   }
   out << "\n";
   out << "temp sizes: ";
   for (auto &i : shmem_info.temp_sizes)
   {
      out << i << " ";
   }
   out << "\n";
   out << "offsets: ";
   for (auto &i : shmem_info.offsets)
   {
      out << i << " ";
   }
   out << "\n";

   func = [this, kernel, num_entities, num_qp, input_dtq_maps,
                 output_dtq_maps, residual_size_on_qp,
                 input_size_on_qp, kinput_to_field, koutput_to_field,
                 output_fop, R, geometric_factors, f_qp, input_fops, output_fops, test_vdim,
                 test_op_dim, num_test_dof, shmem_info, shmem_cache]
   (Vector &ye_mem) mutable
   {
      restriction<entity_t>(op.solutions, solutions_l, this->fields_e,
                            op.element_dof_ordering);
      restriction<entity_t>(op.parameters, parameters_l, this->fields_e,
                            op.element_dof_ordering,
                            op.solutions.size());

      auto r_qp = Reshape(residual_qp_mem.ReadWrite(),
                          residual_size_on_qp, num_qp, num_entities);
      auto ir_weights = Reshape(this->op.integration_rule.GetWeights().Read(), num_qp);
      auto ye = Reshape(ye_mem.ReadWrite(), num_test_dof, test_vdim, num_entities);
      auto wrapped_fields_e = wrap_vectors(this->fields_e);

      forall([=] MFEM_HOST_DEVICE (int e, double *shmem)
      {
         // auto dtq = load_dtq_mem(shmem,
         //                         shmem_info.offsets[SharedMemory::Index::DTQ],
         //                         shmem_info.dtq_sizes,
         //                         input_dtq_maps);

         auto fields = load_field_mem(shmem,
                                      shmem_info.offsets[SharedMemory::Index::FIELD],
                                      shmem_info.field_sizes,
                                      wrapped_fields_e);

         auto input_qp = load_input_mem(shmem,
                                        shmem_info.offsets[SharedMemory::Index::INPUT],
                                        shmem_info.input_sizes,
                                        num_qp);

         auto scratch_mem = load_scratch_mem(shmem,
                                             shmem_info.offsets[SharedMemory::Index::TEMP],
                                             shmem_info.temp_sizes);

         map_fields_to_quadrature_data<mfem::TensorProduct>(
            input_qp, e, fields,
            kinput_to_field, input_dtq_maps,
            ir_weights, geometric_factors, input_fops, scratch_mem,
         std::make_index_sequence<kernel.num_kinputs> {});

         for (int q = 0; q < num_qp; q++)
         {
            auto kernel_args = decay_tuple<typename kernel_t::kf_param_ts> {};
            auto r = Reshape(&r_qp(0, q, e), residual_size_on_qp);
            apply_kernel(r, kernel.func, kernel_args, input_qp, q);
         }

         auto fhat = Reshape(&r_qp(0, 0, e), test_vdim, test_op_dim, num_qp);
         auto y = Reshape(&ye(0, 0, e), num_test_dof, test_vdim);
         map_quadrature_data_to_fields<mfem::TensorProduct>(y, fhat,
                                                            serac::get<0>(output_fops),
                                                            output_dtq_maps[hardcoded_output_idx],
                                                            scratch_mem);
      }, num_entities, 1, shmem_info.total_size, shmem_cache.GetData());

      R->MultTranspose(ye_mem, residual_l);
   };

   if constexpr (std::is_same_v<decltype(output_fop), One>)
   {
      restriction_transpose = [](Vector &r_e, Vector &y)
      {
         y = r_e;
      };

      prolongation_transpose = [&](Vector &r_local, Vector &y)
      {
         double local_sum = r_local.Sum();
         MPI_Allreduce(&local_sum, y.GetData(), 1, MPI_DOUBLE, MPI_SUM,
                       op.mesh.GetComm());
         MFEM_ASSERT(y.Size() == 1, "output size doesn't match kernel description");
      };
   }
   else
   {
      auto P = get_prolongation(op.fields[test_space_field_idx]);
      prolongation_transpose = [P](const Vector &r_local, Vector &y)
      {
         P->MultTranspose(r_local, y);
      };
   }
}
