template <
   typename kernels_tuple,
   size_t num_solutions,
   size_t num_parameters,
   size_t num_fields,
   size_t num_kernels
   >
template <
   size_t derivative_idx
   >
template <
   typename kernel_t
   >
void DifferentiableOperator<kernels_tuple,
     num_solutions,
     num_parameters,
     num_fields,
     num_kernels>::Derivative<derivative_idx>::create_callback(kernel_t kernel,
                                                               mult_func_t &func)
{
   using entity_t = typename kernel_t::entity_t;

   auto kinput_to_field = create_descriptors_to_fields_map<entity_t>(op.fields,
                                                                     kernel.inputs, std::make_index_sequence<kernel.num_kinputs> {});

   auto koutput_to_field = create_descriptors_to_fields_map<entity_t>(op.fields,
                                                                      kernel.outputs, std::make_index_sequence<kernel.num_koutputs> {});

   constexpr int hardcoded_output_idx = 0;
   const int test_space_field_idx = koutput_to_field[hardcoded_output_idx];

   auto output_fop = std::get<0>(kernel.outputs);

   const int num_el = op.mesh.GetNE();
   const int num_qp = op.integration_rule.GetNPoints();

   // assume only a single element type for now
   std::vector<const DofToQuad*> dtqmaps;
   for (const auto &field : op.fields)
   {
      dtqmaps.emplace_back(GetDofToQuad<entity_t>(field, op.integration_rule,
                                                  doftoquad_mode));
   }

   derivative_action_e.SetSize(GetVDim(op.fields[test_space_field_idx]) * num_el *
                               num_qp);

   const int da_size_on_qp = GetSizeOnQP<entity_t>(std::get<0>(kernel.outputs),
                                                   op.fields[test_space_field_idx]);

   da_qp_mem.SetSize(da_size_on_qp * num_qp * num_el);

   // Allocate memory for fields on quadrature points
   auto input_qp_mem = create_input_qp_memory(num_qp, kernel.inputs,
                                              std::make_index_sequence<kernel.num_kinputs> {});

   auto directions_qp_mem = create_input_qp_memory(num_qp, kernel.inputs,
                                                   std::make_index_sequence<kernel.num_kinputs> {});

   for (auto &d_qp_mem : directions_qp_mem)
   {
      d_qp_mem = 0.0;
   }

   const Operator *R = nullptr;
   if constexpr (std::is_same_v<entity_t, Entity::Element>)
   {
      R = get_element_restriction(op.fields[test_space_field_idx],
                                  element_dof_ordering);
   }
   else
   {
      MFEM_ABORT("restriction not implemented for Entity");
   }

   func = [this, kernel, num_el, num_qp, dtqmaps, da_size_on_qp, input_qp_mem,
                 directions_qp_mem,
                 kinput_to_field, koutput_to_field, output_fop, R]
   (Vector &ye_mem) mutable
   {
      if constexpr (std::is_same_v<entity_t, Entity::Element>)
      {
         element_restriction(directions, directions_l, directions_e,
                             op.element_dof_ordering, derivative_idx);
      }
      else
      {
         MFEM_ABORT("restriction not implemented for Entity");
      }

      // Check which qf inputs are dependent on the dependent variable
      std::array<bool, kernel.num_kinputs> kinput_is_dependent;
      bool no_qfinput_is_dependent = true;
      for (int i = 0; i < kinput_is_dependent.size(); i++)
      {
         if (kinput_to_field[i] == derivative_idx)
         {
            no_qfinput_is_dependent = false;
            kinput_is_dependent[i] = true;
            out << "function input " << i << " is dependent on "
                << op.fields[kinput_to_field[i]].field_label << "\n";
         }
         else
         {
            kinput_is_dependent[i] = false;
         }
      }

      if (no_qfinput_is_dependent)
      {
         return;
      }

      const auto da_qp = Reshape(da_qp_mem.ReadWrite(), da_size_on_qp, num_qp, num_el);

      auto kernel_args = decay_tuple<typename kernel_t::kf_param_ts> {};
      auto kernel_shadow_args = decay_tuple<typename kernel_t::kf_param_ts> {};

      DeviceTensor<1, const double> integration_weights(
         this->op.integration_rule.GetWeights().Read(), num_qp);

      // Fields interpolated to the quadrature points in the order of
      // kernel function arguments
      auto input_qp = map_inputs_to_memory(input_qp_mem, num_qp,
                                           kernel.inputs,
                                           std::make_index_sequence<kernel.num_kinputs> {});

      auto directions_qp = map_inputs_to_memory(directions_qp_mem, num_qp,
                                                kernel.inputs,
                                                std::make_index_sequence<kernel.num_kinputs> {});

      auto input_dtq_ops = create_dtq_operators<entity_t>(kernel.inputs, dtqmaps, kinput_to_field);
      auto output_dtq_ops = create_dtq_operators<entity_t>(kernel.outputs, dtqmaps, koutput_to_field);

      constexpr int fixed_output_idx = 0;
      auto Bv = output_dtq_ops[fixed_output_idx];
      auto [num_test_qp, test_op_dim, num_test_dof] = Bv.GetShape();

      const int test_vdim = std::get<0>(kernel.outputs).vdim;

      DeviceTensor<3> ye = Reshape(ye_mem.ReadWrite(), num_test_dof, test_vdim, num_el);

      Vector f_qp(da_size_on_qp);

      for (int e = 0; e < num_el; e++)
      {
         map_fields_to_quadrature_data(
            input_qp, e, this->fields_e,
            kinput_to_field, input_dtq_ops,
            integration_weights, kernel.inputs,
            std::make_index_sequence<kernel.num_kinputs> {});

         map_fields_to_quadrature_data_conditional(
            directions_qp, e,
            directions_e, derivative_idx,
            input_dtq_ops,
            integration_weights,
            kinput_is_dependent,
            kernel.inputs,
            std::make_index_sequence<kernel.num_kinputs> {});

         for (int qp = 0; qp < num_qp; qp++)
         {
            f_qp = apply_kernel_fwddiff_enzyme(
                      kernel.func,
                      kernel_args,
                      input_qp,
                      kernel_shadow_args,
                      directions_qp,
                      qp);
            // f_qp = apply_kernel_fwddiff_dual(
            //           kernel.func,
            //           kernel_args,
            //           input_qp,
            //           directions_qp,
            //           qp);

            auto r_qp = Reshape(&da_qp(0, qp, e), da_size_on_qp);
            for (int i = 0; i < da_size_on_qp; i++)
            {
               r_qp(i) = f_qp(i);
            }
         }

         DeviceTensor<3> fhat = Reshape(&da_qp(0, 0, e), test_vdim, test_op_dim, num_qp);
         DeviceTensor<2> y = Reshape(&ye(0, 0, e), num_test_dof, test_vdim);
         map_quadrature_data_to_fields(y, fhat,
                                       output_fop,
                                       output_dtq_ops[hardcoded_output_idx]);
         R->MultTranspose(ye_mem, derivative_action_l);
      }
   };

   if constexpr (std::is_same_v<decltype(output_fop), One>)
   {
      restriction_transpose = [](Vector &r_e, Vector &y)
      {
         y = r_e;
      };

      prolongation_transpose = [&](Vector &r_local, Vector &y)
      {
         double local_sum = r_local.Sum();
         MPI_Allreduce(&local_sum, y.GetData(), 1, MPI_DOUBLE, MPI_SUM,
                       op.mesh.GetComm());
         MFEM_ASSERT(y.Size() == 1, "output size doesn't match kernel description");
      };
   }
   else
   {
      auto R = get_element_restriction(op.fields[test_space_field_idx],
                                       element_dof_ordering);
      restriction_transpose = [R](Vector &r_e, Vector &y)
      {
         R->MultTranspose(r_e, y);
      };

      auto P = get_prolongation(op.fields[test_space_field_idx]);
      prolongation_transpose = [P](Vector &r_l, Vector &y)
      {
         P->MultTranspose(r_l, y);
      };
   }
}
